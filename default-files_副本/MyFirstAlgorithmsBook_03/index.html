<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>重读-《我的第一本算法书》-03 非线性排列的数据结构 | 小九的酒窝</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/all.min.css">
<link rel="shortcut icon" href="https://hudaqian.github.io/favicon.ico?v=1638114699559">
<link rel="stylesheet" href="https://hudaqian.github.io/styles/main.css">




  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css" />
  

  


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="堆
二叉查找树

堆
堆是一种图的树形结构，被用于实现“优先排列”。优先排列是以一种数据结构，可以自由的添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为结点，数据就存在这些结点中。
堆中每个结点最多有两个子结..." />
    <meta name="keywords" content="算法" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://hudaqian.github.io">
        <img src="https://hudaqian.github.io/images/avatar.png?v=1638114699559" class="site-logo">
        <h1 class="site-title">小九的酒窝</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://hudaqian.github.io/post/aboutme" class="site-nav">
            关于
          </a>
        
      
        
          <a href="https://github.com/HuDaQian" class="site-nav" target="_blank">
            Github
          </a>
        
      
        
          <a href="https://hudaqian.github.io/GameLibrary/My2048/index.html" class="site-nav" target="_blank">
            2048
          </a>
        
      
        
          <a href="https://hudaqian.github.io/GameLibrary/CatGame/index.html" class="site-nav" target="_blank">
            CatchCat
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      <h3>最香不过荷包蛋<br>最美不过夜归人<h3>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">重读-《我的第一本算法书》-03 非线性排列的数据结构</h2>
            <div class="post-date">2020-11-29</div>
            
            <div class="post-content" v-pre>
              <p>堆<br>
二叉查找树</p>
<!-- more -->
<h1 id="堆">堆</h1>
<p>堆是一种图的树形结构，被用于实现“优先排列”。优先排列是以一种数据结构，可以自由的添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为结点，数据就存在这些结点中。<br>
堆中每个结点最多有两个子结点，同一行里则为从左到右。在堆中存储数据必须遵守一条准则：子结点必定大于父结点，因此最小值被存储在顶端的根结点中。往堆中添加数据的时候，为了遵守这个准则，一般会把新数据放到最下边一行靠左的位置，当最下边一行没有多余位置的时候，就向下另起一行，把数据加在这一行的最左边。<br>
从堆中取出数据的时候，取出的是最上边的数据，这样堆中就能始终保持最上边的数字最小。取出顶端数据以后，将最新添加的数据移动到最顶端，然后重新排序，依次将父结点跟数字比较小的子结点进行交换。</p>
<pre><code>从堆中取出最小值的时间复杂度都为o(1)，重新排序的话，重构树所要运行的时间跟树的高度成正比，重构树的时间复杂度为o(log n)。
添加数据要从下到上依次比较，所以你时间复杂度也是o(log n)。
</code></pre>
<h1 id="二叉查找树">二叉查找树</h1>
<p>二叉查找树也采用了图的树形结构。二叉查找树有两个性质，一是每个结点的值均大于其左子树上任意结点的值，二是每个结点的值均小于其右子树上任意一个结点的值。根据这两个性质可以得到几个推论。首先，二叉查找树的最小结点要从顶端开始，往其左下的末端查找，反过来，要查找最大值的时候，也要从顶端开始，往其右下的末端查询。<br>
要添加数据的时候，从顶端开始，依次向下比较，如果比结点保存的数据小，那么向左边子树查询，如果比结点保存的数据大，那么向右边子树查询，直到查找到没有结点为止，将新结点添加到该位置为止。<br>
删除数据的时候，如果没有子结点，那么直接删除该结点，如果只有一个子结点，那么将子结点移动到该结点的位置，如果有两个子结点的话，那么在被删除的左子树中寻找最大结点，然后将最大子结点移动到被删除的结点的位置上，如果最大子结点还有子结点，那么按照之前的操作执行就好了。<br>
查找的话，从顶端开始，如果小于结点中的数据，那么向左查找，如果大于结点中的数据，那么向右查找。<br>
在查找数据或者添加数据的时候，需要和现有的数据比较，比较的次数取决于树的高度，如果树形状比较均衡的话，那么时间复杂度为o(log n)，如果树的结构偏向一侧的话，树的高度会很高，时间复杂度为o(n).</p>
<pre><code>    有一些以二叉查找树为基础扩展的数据结构，比如平衡二叉树：这种数据结构可以修正形状不均衡的树用以提高查找效率。
    另外，虽然二叉查找树中有一个结点最多只有两个子结点，但我们可以把子结点扩展为m（m为预先设定的常数）。像这种子结点数可以自由设定，并且形状均衡的树便是B树。
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://hudaqian.github.io/tag/Algorithms/" class="tag">
                    算法
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://hudaqian.github.io/MyFirstAlgorithmsBook_02/">
                  <h3 class="post-title">
                    重读-《我的第一本算法书》-02 线性排列的数据结构
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.min.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '70e70574c307d3e0aab1',
        clientSecret: 'f4cac46a3ae606b5b74da444d7e6afbfbdea51d0',
        repo: 'hudaqian.github.io',
        owner: 'HuDaQian',
        admin: ['HuDaQian'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
